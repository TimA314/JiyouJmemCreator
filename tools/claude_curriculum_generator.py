#!/usr/bin/env python3
"""
Curriculum generator using Claude's knowledge.
Generates high-quality Q&A pairs for coding topics.
"""

import json
from pathlib import Path
from typing import List, Dict

OUTPUT_DIR = Path(__file__).parent.parent / "curricula" / "coding.jcur" / "lessons"


def create_lesson(lesson_id: str, title: str, description: str, items: List[Dict], tags: List[str]) -> Dict:
    """Create a lesson structure."""
    return {
        "lesson_id": f"coding_{lesson_id}",
        "title": f"Coding: {title}",
        "description": description,
        "category": "coding",
        "difficulty": 3,
        "estimated_minutes": max(30, len(items) // 5),
        "tags": ["coding", "programming"] + tags,
        "items": items
    }


def create_item(category: str, idx: int, source: str, target: str) -> Dict:
    """Create a single Q&A item."""
    return {
        "id": f"code_{category}_{idx:04d}",
        "type": "dialogue",
        "source": source,
        "target": target,
        "context": category
    }


def save_lesson(filename: str, lesson: Dict):
    """Save lesson to JSON file."""
    output_path = OUTPUT_DIR / filename
    with open(output_path, 'w', encoding='utf-8') as f:
        json.dump(lesson, f, indent=2, ensure_ascii=False)
    print(f"Created: {filename} ({len(lesson['items'])} items)")


# ============================================================================
# REACT FUNDAMENTALS
# ============================================================================

REACT_ITEMS = [
    # JSX Basics
    ("What is JSX and how does it differ from HTML?",
     "JSX is a syntax extension for JavaScript that looks like HTML but compiles to `React.createElement()` calls. Key differences:\n\n```jsx\n// JSX uses className instead of class\n<div className=\"container\">Content</div>\n\n// Self-closing tags required\n<img src=\"photo.jpg\" />\n<input type=\"text\" />\n\n// JavaScript expressions in curly braces\n<h1>{user.name}</h1>\n<p>{isLoggedIn ? 'Welcome' : 'Please login'}</p>\n\n// Style is an object, not string\n<div style={{ color: 'red', fontSize: '16px' }}>Styled</div>\n\n// htmlFor instead of for\n<label htmlFor=\"email\">Email</label>\n```\nJSX must have one root element (use `<>...</>` fragments for multiple)."),

    ("How do I create a functional component in React?",
     "Functional components are JavaScript functions that return JSX. They can use hooks for state and lifecycle:\n\n```jsx\nimport { useState } from 'react';\n\n// Basic component\nfunction Greeting({ name }) {\n  return <h1>Hello, {name}!</h1>;\n}\n\n// Arrow function with state\nconst Counter = () => {\n  const [count, setCount] = useState(0);\n  \n  return (\n    <div>\n      <p>Count: {count}</p>\n      <button onClick={() => setCount(count + 1)}>\n        Increment\n      </button>\n    </div>\n  );\n};\n\n// With TypeScript\ninterface Props {\n  name: string;\n  age?: number;\n}\n\nconst User: React.FC<Props> = ({ name, age = 0 }) => (\n  <div>{name} is {age} years old</div>\n);\n```\nExport with `export default ComponentName;`"),

    ("How does useState work? Show examples with different data types.",
     "`useState` returns a state value and setter function. Works with any data type:\n\n```jsx\nimport { useState } from 'react';\n\nfunction Examples() {\n  // Primitives\n  const [count, setCount] = useState(0);\n  const [name, setName] = useState('');\n  const [isOpen, setIsOpen] = useState(false);\n  \n  // Arrays - always create new array\n  const [items, setItems] = useState([]);\n  const addItem = (item) => setItems([...items, item]);\n  const removeItem = (id) => setItems(items.filter(i => i.id !== id));\n  \n  // Objects - spread to preserve other fields\n  const [user, setUser] = useState({ name: '', email: '' });\n  const updateName = (name) => setUser({ ...user, name });\n  \n  // Lazy initialization for expensive computations\n  const [data, setData] = useState(() => expensiveComputation());\n  \n  // Functional update when depending on previous state\n  const increment = () => setCount(prev => prev + 1);\n  \n  return <div>...</div>;\n}\n```\nNever mutate state directly—always create new references."),

    ("What is useEffect and when should I use it?",
     "`useEffect` runs side effects after render. Controls when effects run via dependencies:\n\n```jsx\nimport { useState, useEffect } from 'react';\n\nfunction DataFetcher({ userId }) {\n  const [data, setData] = useState(null);\n  const [loading, setLoading] = useState(true);\n  \n  // Runs on mount and when userId changes\n  useEffect(() => {\n    let cancelled = false;\n    setLoading(true);\n    \n    fetch(`/api/users/${userId}`)\n      .then(res => res.json())\n      .then(data => {\n        if (!cancelled) {\n          setData(data);\n          setLoading(false);\n        }\n      });\n    \n    // Cleanup function\n    return () => { cancelled = true; };\n  }, [userId]);  // Dependency array\n  \n  // Empty array = run once on mount\n  useEffect(() => {\n    console.log('Component mounted');\n    return () => console.log('Component unmounted');\n  }, []);\n  \n  // No array = run after every render (rarely needed)\n  useEffect(() => {\n    document.title = `Data: ${data?.name}`;\n  });\n  \n  if (loading) return <p>Loading...</p>;\n  return <pre>{JSON.stringify(data, null, 2)}</pre>;\n}\n```\nAlways include all dependencies or use eslint-plugin-react-hooks."),

    ("How do I handle forms in React?",
     "React forms use controlled components where state drives input values:\n\n```jsx\nimport { useState } from 'react';\n\nfunction LoginForm({ onSubmit }) {\n  const [formData, setFormData] = useState({\n    email: '',\n    password: '',\n    remember: false\n  });\n  const [errors, setErrors] = useState({});\n  \n  const handleChange = (e) => {\n    const { name, value, type, checked } = e.target;\n    setFormData(prev => ({\n      ...prev,\n      [name]: type === 'checkbox' ? checked : value\n    }));\n  };\n  \n  const handleSubmit = (e) => {\n    e.preventDefault();\n    \n    // Validation\n    const newErrors = {};\n    if (!formData.email) newErrors.email = 'Email required';\n    if (formData.password.length < 8) {\n      newErrors.password = 'Min 8 characters';\n    }\n    \n    if (Object.keys(newErrors).length) {\n      setErrors(newErrors);\n      return;\n    }\n    \n    onSubmit(formData);\n  };\n  \n  return (\n    <form onSubmit={handleSubmit}>\n      <input\n        name=\"email\"\n        type=\"email\"\n        value={formData.email}\n        onChange={handleChange}\n      />\n      {errors.email && <span>{errors.email}</span>}\n      \n      <input\n        name=\"password\"\n        type=\"password\"\n        value={formData.password}\n        onChange={handleChange}\n      />\n      \n      <label>\n        <input\n          name=\"remember\"\n          type=\"checkbox\"\n          checked={formData.remember}\n          onChange={handleChange}\n        />\n        Remember me\n      </label>\n      \n      <button type=\"submit\">Login</button>\n    </form>\n  );\n}\n```"),

    ("What is useContext and how do I create a context provider?",
     "`useContext` shares state across components without prop drilling:\n\n```jsx\nimport { createContext, useContext, useState } from 'react';\n\n// Create context with default value\nconst ThemeContext = createContext('light');\n\n// Provider component\nfunction ThemeProvider({ children }) {\n  const [theme, setTheme] = useState('light');\n  \n  const toggleTheme = () => {\n    setTheme(prev => prev === 'light' ? 'dark' : 'light');\n  };\n  \n  return (\n    <ThemeContext.Provider value={{ theme, toggleTheme }}>\n      {children}\n    </ThemeContext.Provider>\n  );\n}\n\n// Custom hook for consuming context\nfunction useTheme() {\n  const context = useContext(ThemeContext);\n  if (!context) {\n    throw new Error('useTheme must be used within ThemeProvider');\n  }\n  return context;\n}\n\n// Usage in any nested component\nfunction ThemedButton() {\n  const { theme, toggleTheme } = useTheme();\n  \n  return (\n    <button\n      onClick={toggleTheme}\n      style={{ background: theme === 'dark' ? '#333' : '#fff' }}\n    >\n      Current: {theme}\n    </button>\n  );\n}\n\n// App setup\nfunction App() {\n  return (\n    <ThemeProvider>\n      <ThemedButton />\n    </ThemeProvider>\n  );\n}\n```"),

    ("How does useReducer work for complex state?",
     "`useReducer` manages complex state with actions, similar to Redux:\n\n```jsx\nimport { useReducer } from 'react';\n\n// Define action types\nconst ACTIONS = {\n  ADD_TODO: 'add',\n  TOGGLE_TODO: 'toggle',\n  DELETE_TODO: 'delete',\n  CLEAR_COMPLETED: 'clear'\n};\n\n// Reducer function\nfunction todoReducer(state, action) {\n  switch (action.type) {\n    case ACTIONS.ADD_TODO:\n      return [...state, {\n        id: Date.now(),\n        text: action.payload,\n        completed: false\n      }];\n    case ACTIONS.TOGGLE_TODO:\n      return state.map(todo =>\n        todo.id === action.payload\n          ? { ...todo, completed: !todo.completed }\n          : todo\n      );\n    case ACTIONS.DELETE_TODO:\n      return state.filter(todo => todo.id !== action.payload);\n    case ACTIONS.CLEAR_COMPLETED:\n      return state.filter(todo => !todo.completed);\n    default:\n      return state;\n  }\n}\n\nfunction TodoApp() {\n  const [todos, dispatch] = useReducer(todoReducer, []);\n  const [input, setInput] = useState('');\n  \n  const addTodo = () => {\n    if (input.trim()) {\n      dispatch({ type: ACTIONS.ADD_TODO, payload: input });\n      setInput('');\n    }\n  };\n  \n  return (\n    <div>\n      <input value={input} onChange={e => setInput(e.target.value)} />\n      <button onClick={addTodo}>Add</button>\n      \n      {todos.map(todo => (\n        <div key={todo.id}>\n          <span\n            style={{ textDecoration: todo.completed ? 'line-through' : 'none' }}\n            onClick={() => dispatch({ type: ACTIONS.TOGGLE_TODO, payload: todo.id })}\n          >\n            {todo.text}\n          </span>\n          <button onClick={() => dispatch({ type: ACTIONS.DELETE_TODO, payload: todo.id })}>\n            Delete\n          </button>\n        </div>\n      ))}\n    </div>\n  );\n}\n```\nPrefer useReducer when state logic is complex or involves multiple sub-values."),

    ("What are custom hooks and how do I create one?",
     "Custom hooks extract reusable stateful logic. Name must start with 'use':\n\n```jsx\nimport { useState, useEffect, useCallback } from 'react';\n\n// Fetch hook with loading/error states\nfunction useFetch(url) {\n  const [data, setData] = useState(null);\n  const [loading, setLoading] = useState(true);\n  const [error, setError] = useState(null);\n  \n  useEffect(() => {\n    const controller = new AbortController();\n    \n    setLoading(true);\n    fetch(url, { signal: controller.signal })\n      .then(res => res.json())\n      .then(setData)\n      .catch(err => {\n        if (err.name !== 'AbortError') setError(err);\n      })\n      .finally(() => setLoading(false));\n    \n    return () => controller.abort();\n  }, [url]);\n  \n  return { data, loading, error };\n}\n\n// Local storage hook\nfunction useLocalStorage(key, initialValue) {\n  const [value, setValue] = useState(() => {\n    const stored = localStorage.getItem(key);\n    return stored ? JSON.parse(stored) : initialValue;\n  });\n  \n  useEffect(() => {\n    localStorage.setItem(key, JSON.stringify(value));\n  }, [key, value]);\n  \n  return [value, setValue];\n}\n\n// Debounce hook\nfunction useDebounce(value, delay = 500) {\n  const [debounced, setDebounced] = useState(value);\n  \n  useEffect(() => {\n    const timer = setTimeout(() => setDebounced(value), delay);\n    return () => clearTimeout(timer);\n  }, [value, delay]);\n  \n  return debounced;\n}\n\n// Usage\nfunction SearchComponent() {\n  const [query, setQuery] = useState('');\n  const debouncedQuery = useDebounce(query, 300);\n  const { data, loading } = useFetch(`/api/search?q=${debouncedQuery}`);\n  const [history, setHistory] = useLocalStorage('searchHistory', []);\n  \n  return <div>...</div>;\n}\n```"),

    ("How do useMemo and useCallback optimize performance?",
     "`useMemo` memoizes computed values; `useCallback` memoizes functions:\n\n```jsx\nimport { useState, useMemo, useCallback, memo } from 'react';\n\n// Memoized child component\nconst ExpensiveList = memo(({ items, onItemClick }) => {\n  console.log('ExpensiveList rendered');\n  return (\n    <ul>\n      {items.map(item => (\n        <li key={item.id} onClick={() => onItemClick(item.id)}>\n          {item.name}\n        </li>\n      ))}\n    </ul>\n  );\n});\n\nfunction Parent({ data }) {\n  const [filter, setFilter] = useState('');\n  const [selected, setSelected] = useState(null);\n  \n  // useMemo: recompute only when data or filter changes\n  const filteredItems = useMemo(() => {\n    console.log('Filtering items...');\n    return data.filter(item =>\n      item.name.toLowerCase().includes(filter.toLowerCase())\n    );\n  }, [data, filter]);\n  \n  // useCallback: stable function reference\n  const handleItemClick = useCallback((id) => {\n    setSelected(id);\n  }, []);  // No dependencies = never recreated\n  \n  // Without useCallback, ExpensiveList re-renders every time\n  // because onClick would be a new function each render\n  \n  return (\n    <div>\n      <input\n        value={filter}\n        onChange={e => setFilter(e.target.value)}\n        placeholder=\"Filter...\"\n      />\n      <ExpensiveList\n        items={filteredItems}\n        onItemClick={handleItemClick}\n      />\n      <p>Selected: {selected}</p>\n    </div>\n  );\n}\n```\nOnly use these when you have measured performance issues. Premature optimization adds complexity."),

    ("How do I use useRef for DOM access and mutable values?",
     "`useRef` holds mutable values that persist across renders without causing re-renders:\n\n```jsx\nimport { useRef, useEffect, useState } from 'react';\n\nfunction TextInput() {\n  const inputRef = useRef(null);\n  \n  // Focus input on mount\n  useEffect(() => {\n    inputRef.current.focus();\n  }, []);\n  \n  return <input ref={inputRef} />;\n}\n\nfunction Timer() {\n  const [count, setCount] = useState(0);\n  const intervalRef = useRef(null);\n  const countRef = useRef(count);  // Track current count\n  \n  // Keep ref in sync with state\n  useEffect(() => {\n    countRef.current = count;\n  }, [count]);\n  \n  const start = () => {\n    if (intervalRef.current) return;\n    intervalRef.current = setInterval(() => {\n      setCount(c => c + 1);\n    }, 1000);\n  };\n  \n  const stop = () => {\n    clearInterval(intervalRef.current);\n    intervalRef.current = null;\n  };\n  \n  const log = () => {\n    // countRef.current always has latest value\n    console.log('Current count:', countRef.current);\n  };\n  \n  useEffect(() => {\n    return () => clearInterval(intervalRef.current);\n  }, []);\n  \n  return (\n    <div>\n      <p>{count}</p>\n      <button onClick={start}>Start</button>\n      <button onClick={stop}>Stop</button>\n      <button onClick={log}>Log</button>\n    </div>\n  );\n}\n\n// Forward ref to child components\nconst FancyInput = forwardRef((props, ref) => (\n  <input ref={ref} className=\"fancy\" {...props} />\n));\n```"),

    ("How do I render lists in React with proper keys?",
     "Use `map()` to render lists. Keys help React identify which items changed:\n\n```jsx\nfunction TodoList({ todos }) {\n  return (\n    <ul>\n      {todos.map(todo => (\n        // Key should be stable, unique identifier\n        <li key={todo.id}>\n          {todo.text}\n        </li>\n      ))}\n    </ul>\n  );\n}\n\n// BAD: Using index as key (causes issues with reordering)\nfunction BadList({ items }) {\n  return items.map((item, index) => (\n    <div key={index}>{item}</div>  // Don't do this!\n  ));\n}\n\n// Rendering with conditional content\nfunction UserList({ users, isAdmin }) {\n  if (users.length === 0) {\n    return <p>No users found</p>;\n  }\n  \n  return (\n    <div>\n      {users.map(user => (\n        <div key={user.id} className=\"user-card\">\n          <h3>{user.name}</h3>\n          <p>{user.email}</p>\n          {isAdmin && (\n            <button onClick={() => deleteUser(user.id)}>\n              Delete\n            </button>\n          )}\n        </div>\n      ))}\n    </div>\n  );\n}\n\n// Nested lists\nfunction CategoryList({ categories }) {\n  return categories.map(cat => (\n    <div key={cat.id}>\n      <h2>{cat.name}</h2>\n      <ul>\n        {cat.items.map(item => (\n          <li key={item.id}>{item.name}</li>\n        ))}\n      </ul>\n    </div>\n  ));\n}\n```\nKeys must be unique among siblings, not globally unique."),

    ("What is conditional rendering in React?",
     "Multiple patterns for showing/hiding content based on conditions:\n\n```jsx\nfunction Dashboard({ user, notifications, loading }) {\n  // Early return pattern\n  if (loading) {\n    return <Spinner />;\n  }\n  \n  if (!user) {\n    return <LoginPrompt />;\n  }\n  \n  return (\n    <div>\n      {/* Ternary for either/or */}\n      {user.isAdmin ? (\n        <AdminPanel />\n      ) : (\n        <UserPanel />\n      )}\n      \n      {/* && for show/hide (falsy values render nothing) */}\n      {notifications.length > 0 && (\n        <NotificationBadge count={notifications.length} />\n      )}\n      \n      {/* Avoid 0 rendering with explicit boolean */}\n      {notifications.length > 0 && <Badge />}  {/* Shows \"0\" if length is 0! */}\n      {notifications.length ? <Badge /> : null}  {/* Correct */}\n      \n      {/* Switch-like with object lookup */}\n      {{\n        pending: <PendingStatus />,\n        approved: <ApprovedStatus />,\n        rejected: <RejectedStatus />\n      }[user.status]}\n      \n      {/* Inline IIFE for complex logic */}\n      {(() => {\n        if (user.role === 'admin') return <Admin />;\n        if (user.role === 'mod') return <Moderator />;\n        return <User />;\n      })()}\n    </div>\n  );\n}\n\n// Component for cleaner conditionals\nfunction Show({ when, fallback = null, children }) {\n  return when ? children : fallback;\n}\n\n// Usage\n<Show when={isLoggedIn} fallback={<Login />}>\n  <Dashboard />\n</Show>\n```"),

    ("How do I handle events in React?",
     "React events are camelCase and receive synthetic events:\n\n```jsx\nimport { useState } from 'react';\n\nfunction EventExamples() {\n  const [position, setPosition] = useState({ x: 0, y: 0 });\n  \n  // Click with event object\n  const handleClick = (e) => {\n    e.preventDefault();  // Prevent default behavior\n    e.stopPropagation();  // Stop bubbling\n    console.log('Clicked at', e.clientX, e.clientY);\n  };\n  \n  // Passing arguments to handlers\n  const handleItemClick = (id, e) => {\n    console.log('Item:', id, 'Event:', e);\n  };\n  \n  // Keyboard events\n  const handleKeyDown = (e) => {\n    if (e.key === 'Enter') {\n      submitForm();\n    }\n    if (e.key === 'Escape') {\n      closeModal();\n    }\n  };\n  \n  // Mouse move\n  const handleMouseMove = (e) => {\n    setPosition({ x: e.clientX, y: e.clientY });\n  };\n  \n  return (\n    <div onMouseMove={handleMouseMove}>\n      <button onClick={handleClick}>Click me</button>\n      \n      {/* Passing arguments */}\n      {items.map(item => (\n        <div\n          key={item.id}\n          onClick={(e) => handleItemClick(item.id, e)}\n        >\n          {item.name}\n        </div>\n      ))}\n      \n      <input\n        onKeyDown={handleKeyDown}\n        onFocus={() => console.log('focused')}\n        onBlur={() => console.log('blurred')}\n        onChange={(e) => console.log(e.target.value)}\n      />\n      \n      <form onSubmit={(e) => {\n        e.preventDefault();\n        handleSubmit();\n      }}>\n        <button type=\"submit\">Submit</button>\n      </form>\n      \n      <p>Position: {position.x}, {position.y}</p>\n    </div>\n  );\n}\n```"),

    ("How do I pass data between parent and child components?",
     "Data flows down via props, up via callbacks:\n\n```jsx\n// Parent passes data down\nfunction Parent() {\n  const [items, setItems] = useState([]);\n  \n  // Handler passed to child\n  const handleAddItem = (newItem) => {\n    setItems([...items, newItem]);\n  };\n  \n  const handleDeleteItem = (id) => {\n    setItems(items.filter(item => item.id !== id));\n  };\n  \n  return (\n    <div>\n      <AddItemForm onAdd={handleAddItem} />\n      <ItemList\n        items={items}\n        onDelete={handleDeleteItem}\n      />\n    </div>\n  );\n}\n\n// Child receives props and calls callbacks\nfunction AddItemForm({ onAdd }) {\n  const [text, setText] = useState('');\n  \n  const handleSubmit = (e) => {\n    e.preventDefault();\n    if (text.trim()) {\n      // Call parent's handler with data\n      onAdd({ id: Date.now(), text });\n      setText('');\n    }\n  };\n  \n  return (\n    <form onSubmit={handleSubmit}>\n      <input\n        value={text}\n        onChange={e => setText(e.target.value)}\n      />\n      <button type=\"submit\">Add</button>\n    </form>\n  );\n}\n\nfunction ItemList({ items, onDelete }) {\n  return (\n    <ul>\n      {items.map(item => (\n        <li key={item.id}>\n          {item.text}\n          <button onClick={() => onDelete(item.id)}>\n            Delete\n          </button>\n        </li>\n      ))}\n    </ul>\n  );\n}\n```\nFor deeply nested components, use Context instead of prop drilling."),

    ("How does React Router work for navigation?",
     "React Router provides declarative routing for SPAs:\n\n```jsx\nimport {\n  BrowserRouter,\n  Routes,\n  Route,\n  Link,\n  NavLink,\n  useParams,\n  useNavigate,\n  useLocation,\n  Navigate,\n  Outlet\n} from 'react-router-dom';\n\n// Route configuration\nfunction App() {\n  return (\n    <BrowserRouter>\n      <nav>\n        <Link to=\"/\">Home</Link>\n        <NavLink\n          to=\"/about\"\n          className={({ isActive }) => isActive ? 'active' : ''}\n        >\n          About\n        </NavLink>\n      </nav>\n      \n      <Routes>\n        <Route path=\"/\" element={<Home />} />\n        <Route path=\"/about\" element={<About />} />\n        <Route path=\"/users\" element={<UsersLayout />}>\n          <Route index element={<UsersList />} />\n          <Route path=\":userId\" element={<UserDetail />} />\n        </Route>\n        <Route path=\"/login\" element={<Login />} />\n        <Route path=\"*\" element={<NotFound />} />\n      </Routes>\n    </BrowserRouter>\n  );\n}\n\n// Nested routes with Outlet\nfunction UsersLayout() {\n  return (\n    <div>\n      <h1>Users</h1>\n      <Outlet />  {/* Child routes render here */}\n    </div>\n  );\n}\n\n// Dynamic route params\nfunction UserDetail() {\n  const { userId } = useParams();\n  const navigate = useNavigate();\n  const location = useLocation();\n  \n  return (\n    <div>\n      <h2>User {userId}</h2>\n      <button onClick={() => navigate(-1)}>Back</button>\n      <button onClick={() => navigate('/users', { replace: true })}>\n        To Users\n      </button>\n    </div>\n  );\n}\n\n// Protected routes\nfunction ProtectedRoute({ children }) {\n  const { user } = useAuth();\n  const location = useLocation();\n  \n  if (!user) {\n    return <Navigate to=\"/login\" state={{ from: location }} replace />;\n  }\n  \n  return children;\n}\n```"),

    ("What are React fragments and when should I use them?",
     "Fragments let you group elements without adding extra DOM nodes:\n\n```jsx\nimport { Fragment } from 'react';\n\n// Problem: JSX needs single root element\nfunction BadComponent() {\n  return (\n    // This adds unnecessary <div> to DOM\n    <div>\n      <h1>Title</h1>\n      <p>Content</p>\n    </div>\n  );\n}\n\n// Solution: Use Fragment\nfunction GoodComponent() {\n  return (\n    <Fragment>\n      <h1>Title</h1>\n      <p>Content</p>\n    </Fragment>\n  );\n}\n\n// Short syntax (most common)\nfunction BetterComponent() {\n  return (\n    <>\n      <h1>Title</h1>\n      <p>Content</p>\n    </>\n  );\n}\n\n// Fragment with key (required in lists)\nfunction Glossary({ items }) {\n  return (\n    <dl>\n      {items.map(item => (\n        // Can't use <> when key is needed\n        <Fragment key={item.id}>\n          <dt>{item.term}</dt>\n          <dd>{item.definition}</dd>\n        </Fragment>\n      ))}\n    </dl>\n  );\n}\n\n// Table rows example (can't have div inside tbody)\nfunction TableRows({ data }) {\n  return (\n    <>\n      {data.map(row => (\n        <tr key={row.id}>\n          <td>{row.name}</td>\n          <td>{row.value}</td>\n        </tr>\n      ))}\n    </>\n  );\n}\n```\nUse fragments when you need multiple elements but don't want wrapper divs."),

    ("How do I handle errors in React with Error Boundaries?",
     "Error Boundaries catch JavaScript errors in child components:\n\n```jsx\nimport { Component } from 'react';\n\n// Error boundaries must be class components\nclass ErrorBoundary extends Component {\n  constructor(props) {\n    super(props);\n    this.state = { hasError: false, error: null };\n  }\n  \n  static getDerivedStateFromError(error) {\n    // Update state to show fallback UI\n    return { hasError: true, error };\n  }\n  \n  componentDidCatch(error, errorInfo) {\n    // Log to error reporting service\n    console.error('Error caught:', error, errorInfo);\n    logErrorToService(error, errorInfo);\n  }\n  \n  render() {\n    if (this.state.hasError) {\n      return (\n        <div className=\"error-fallback\">\n          <h2>Something went wrong</h2>\n          <details>\n            <summary>Error details</summary>\n            <pre>{this.state.error?.message}</pre>\n          </details>\n          <button onClick={() => this.setState({ hasError: false })}>\n            Try again\n          </button>\n        </div>\n      );\n    }\n    \n    return this.props.children;\n  }\n}\n\n// Usage: Wrap components that might error\nfunction App() {\n  return (\n    <ErrorBoundary>\n      <Header />\n      <ErrorBoundary>\n        {/* Isolate dashboard errors */}\n        <Dashboard />\n      </ErrorBoundary>\n      <Footer />\n    </ErrorBoundary>\n  );\n}\n\n// Note: Error boundaries don't catch:\n// - Event handler errors (use try/catch)\n// - Async code (promises)\n// - Server-side rendering\n// - Errors in the boundary itself\n```\nUse react-error-boundary package for hooks-based approach."),

    ("How do I style React components?",
     "Multiple styling approaches in React:\n\n```jsx\n// 1. Inline styles (object)\nfunction InlineStyles() {\n  const styles = {\n    container: {\n      padding: '20px',\n      backgroundColor: '#f0f0f0'\n    },\n    title: {\n      fontSize: '24px',\n      color: 'navy'\n    }\n  };\n  \n  return (\n    <div style={styles.container}>\n      <h1 style={styles.title}>Hello</h1>\n    </div>\n  );\n}\n\n// 2. CSS Modules (recommended)\n// Button.module.css:\n// .button { background: blue; }\n// .primary { background: green; }\nimport styles from './Button.module.css';\n\nfunction Button({ primary, children }) {\n  return (\n    <button className={`${styles.button} ${primary ? styles.primary : ''}`}>\n      {children}\n    </button>\n  );\n}\n\n// 3. CSS-in-JS with styled-components\nimport styled from 'styled-components';\n\nconst StyledButton = styled.button`\n  padding: 10px 20px;\n  background: ${props => props.primary ? 'blue' : 'gray'};\n  color: white;\n  border: none;\n  border-radius: 4px;\n  \n  &:hover {\n    opacity: 0.8;\n  }\n`;\n\nfunction App() {\n  return <StyledButton primary>Click me</StyledButton>;\n}\n\n// 4. Tailwind CSS\nfunction TailwindButton({ children }) {\n  return (\n    <button className=\"px-4 py-2 bg-blue-500 text-white rounded hover:bg-blue-600\">\n      {children}\n    </button>\n  );\n}\n\n// 5. clsx/classnames for conditional classes\nimport clsx from 'clsx';\n\nfunction DynamicStyles({ isActive, isDisabled }) {\n  return (\n    <div className={clsx(\n      'base-class',\n      isActive && 'active',\n      isDisabled && 'disabled',\n      { 'conditional': someCondition }\n    )}>\n      Content\n    </div>\n  );\n}\n```"),

    ("How do I fetch data in React?",
     "Multiple patterns for data fetching:\n\n```jsx\nimport { useState, useEffect } from 'react';\n\n// Basic fetch with useEffect\nfunction BasicFetch() {\n  const [data, setData] = useState(null);\n  const [loading, setLoading] = useState(true);\n  const [error, setError] = useState(null);\n  \n  useEffect(() => {\n    const controller = new AbortController();\n    \n    async function fetchData() {\n      try {\n        const res = await fetch('/api/data', {\n          signal: controller.signal\n        });\n        if (!res.ok) throw new Error('Failed to fetch');\n        const json = await res.json();\n        setData(json);\n      } catch (err) {\n        if (err.name !== 'AbortError') {\n          setError(err);\n        }\n      } finally {\n        setLoading(false);\n      }\n    }\n    \n    fetchData();\n    return () => controller.abort();\n  }, []);\n  \n  if (loading) return <p>Loading...</p>;\n  if (error) return <p>Error: {error.message}</p>;\n  return <pre>{JSON.stringify(data, null, 2)}</pre>;\n}\n\n// Custom useFetch hook\nfunction useFetch(url) {\n  const [state, setState] = useState({\n    data: null,\n    loading: true,\n    error: null\n  });\n  \n  useEffect(() => {\n    const controller = new AbortController();\n    setState(s => ({ ...s, loading: true }));\n    \n    fetch(url, { signal: controller.signal })\n      .then(res => res.json())\n      .then(data => setState({ data, loading: false, error: null }))\n      .catch(error => {\n        if (error.name !== 'AbortError') {\n          setState({ data: null, loading: false, error });\n        }\n      });\n    \n    return () => controller.abort();\n  }, [url]);\n  \n  return state;\n}\n\n// With React Query (recommended for production)\nimport { useQuery, useMutation } from '@tanstack/react-query';\n\nfunction ReactQueryExample() {\n  const { data, isLoading, error } = useQuery({\n    queryKey: ['users'],\n    queryFn: () => fetch('/api/users').then(r => r.json())\n  });\n  \n  const mutation = useMutation({\n    mutationFn: (newUser) => fetch('/api/users', {\n      method: 'POST',\n      body: JSON.stringify(newUser)\n    })\n  });\n  \n  return <div>...</div>;\n}\n```"),

    ("What is React.memo and when should I use it?",
     "`React.memo` prevents re-renders when props haven't changed:\n\n```jsx\nimport { memo, useState, useCallback } from 'react';\n\n// Without memo: re-renders every time parent renders\nfunction ExpensiveComponent({ data, onUpdate }) {\n  console.log('ExpensiveComponent rendered');\n  // ... expensive rendering logic\n  return <div>{data.name}</div>;\n}\n\n// With memo: only re-renders when props change\nconst MemoizedComponent = memo(function ExpensiveComponent({ data, onUpdate }) {\n  console.log('MemoizedComponent rendered');\n  return <div>{data.name}</div>;\n});\n\n// Custom comparison function\nconst CustomMemo = memo(\n  function MyComponent({ user, config }) {\n    return <div>{user.name}</div>;\n  },\n  (prevProps, nextProps) => {\n    // Return true to skip re-render\n    return prevProps.user.id === nextProps.user.id;\n  }\n);\n\n// Parent component\nfunction Parent() {\n  const [count, setCount] = useState(0);\n  const [user, setUser] = useState({ name: 'John' });\n  \n  // Must memoize callbacks for memo to work!\n  const handleUpdate = useCallback((value) => {\n    console.log('Update:', value);\n  }, []);\n  \n  return (\n    <div>\n      <button onClick={() => setCount(c => c + 1)}>\n        Count: {count}\n      </button>\n      \n      {/* This won't re-render when count changes */}\n      <MemoizedComponent\n        data={user}\n        onUpdate={handleUpdate}\n      />\n    </div>\n  );\n}\n```\nUse memo when:\n- Component renders often with same props\n- Component has expensive render logic\n- Parent re-renders frequently\n\nDon't use memo:\n- For simple/cheap components\n- When props change frequently\n- Prematurely (measure first!)"),

    ("How do I use React's children prop?",
     "The `children` prop contains content between component tags:\n\n```jsx\n// Basic children usage\nfunction Card({ children, title }) {\n  return (\n    <div className=\"card\">\n      <h2>{title}</h2>\n      <div className=\"card-body\">\n        {children}\n      </div>\n    </div>\n  );\n}\n\n// Usage\n<Card title=\"Welcome\">\n  <p>This is the card content</p>\n  <button>Click me</button>\n</Card>\n\n// Multiple named slots with props\nfunction Layout({ header, sidebar, children, footer }) {\n  return (\n    <div className=\"layout\">\n      <header>{header}</header>\n      <aside>{sidebar}</aside>\n      <main>{children}</main>\n      <footer>{footer}</footer>\n    </div>\n  );\n}\n\n<Layout\n  header={<Nav />}\n  sidebar={<Menu />}\n  footer={<Copyright />}\n>\n  <Article />\n</Layout>\n\n// Render props pattern\nfunction MouseTracker({ render }) {\n  const [position, setPosition] = useState({ x: 0, y: 0 });\n  \n  return (\n    <div onMouseMove={e => setPosition({ x: e.clientX, y: e.clientY })}>\n      {render(position)}\n    </div>\n  );\n}\n\n<MouseTracker render={({ x, y }) => (\n  <p>Mouse is at {x}, {y}</p>\n)} />\n\n// Children utilities\nimport { Children, cloneElement } from 'react';\n\nfunction Tabs({ children }) {\n  const [active, setActive] = useState(0);\n  \n  return (\n    <div>\n      <div className=\"tab-headers\">\n        {Children.map(children, (child, index) => (\n          <button\n            onClick={() => setActive(index)}\n            className={active === index ? 'active' : ''}\n          >\n            {child.props.label}\n          </button>\n        ))}\n      </div>\n      <div className=\"tab-content\">\n        {Children.toArray(children)[active]}\n      </div>\n    </div>\n  );\n}\n```"),

    ("How do I use portals in React?",
     "Portals render children into a DOM node outside the parent hierarchy:\n\n```jsx\nimport { createPortal } from 'react-dom';\nimport { useState, useEffect } from 'react';\n\n// Basic modal with portal\nfunction Modal({ isOpen, onClose, children }) {\n  if (!isOpen) return null;\n  \n  return createPortal(\n    <div className=\"modal-overlay\" onClick={onClose}>\n      <div className=\"modal-content\" onClick={e => e.stopPropagation()}>\n        <button className=\"close-btn\" onClick={onClose}>×</button>\n        {children}\n      </div>\n    </div>,\n    document.getElementById('modal-root')  // Target DOM node\n  );\n}\n\n// Tooltip with portal\nfunction Tooltip({ text, children }) {\n  const [show, setShow] = useState(false);\n  const [coords, setCoords] = useState({ x: 0, y: 0 });\n  \n  const handleMouseEnter = (e) => {\n    const rect = e.target.getBoundingClientRect();\n    setCoords({\n      x: rect.left + rect.width / 2,\n      y: rect.top - 10\n    });\n    setShow(true);\n  };\n  \n  return (\n    <>\n      <span\n        onMouseEnter={handleMouseEnter}\n        onMouseLeave={() => setShow(false)}\n      >\n        {children}\n      </span>\n      {show && createPortal(\n        <div\n          className=\"tooltip\"\n          style={{\n            position: 'fixed',\n            left: coords.x,\n            top: coords.y,\n            transform: 'translateX(-50%) translateY(-100%)'\n          }}\n        >\n          {text}\n        </div>,\n        document.body\n      )}\n    </>\n  );\n}\n\n// Usage\nfunction App() {\n  const [showModal, setShowModal] = useState(false);\n  \n  return (\n    <div>\n      <button onClick={() => setShowModal(true)}>Open Modal</button>\n      <Modal isOpen={showModal} onClose={() => setShowModal(false)}>\n        <h2>Modal Title</h2>\n        <p>Modal content here</p>\n      </Modal>\n      \n      <Tooltip text=\"Helpful info\">\n        <span>Hover me</span>\n      </Tooltip>\n    </div>\n  );\n}\n```\nAdd `<div id=\"modal-root\"></div>` to your index.html."),

    ("How do I implement code splitting and lazy loading?",
     "Use `React.lazy` and `Suspense` to load components on demand:\n\n```jsx\nimport { lazy, Suspense, useState } from 'react';\n\n// Lazy load components\nconst HeavyChart = lazy(() => import('./HeavyChart'));\nconst AdminDashboard = lazy(() => import('./AdminDashboard'));\n\n// With named exports\nconst Dashboard = lazy(() =>\n  import('./Dashboard').then(module => ({ default: module.Dashboard }))\n);\n\n// Loading fallback component\nfunction LoadingSpinner() {\n  return <div className=\"spinner\">Loading...</div>;\n}\n\n// App with lazy routes\nfunction App() {\n  const [showChart, setShowChart] = useState(false);\n  \n  return (\n    <div>\n      <button onClick={() => setShowChart(true)}>\n        Load Heavy Chart\n      </button>\n      \n      {/* Suspense wraps lazy components */}\n      <Suspense fallback={<LoadingSpinner />}>\n        {showChart && <HeavyChart data={data} />}\n      </Suspense>\n    </div>\n  );\n}\n\n// Route-based code splitting\nimport { BrowserRouter, Routes, Route } from 'react-router-dom';\n\nconst Home = lazy(() => import('./pages/Home'));\nconst About = lazy(() => import('./pages/About'));\nconst Contact = lazy(() => import('./pages/Contact'));\n\nfunction AppWithRoutes() {\n  return (\n    <BrowserRouter>\n      <Suspense fallback={<LoadingSpinner />}>\n        <Routes>\n          <Route path=\"/\" element={<Home />} />\n          <Route path=\"/about\" element={<About />} />\n          <Route path=\"/contact\" element={<Contact />} />\n        </Routes>\n      </Suspense>\n    </BrowserRouter>\n  );\n}\n\n// Error boundary for failed lazy loads\nclass LazyErrorBoundary extends Component {\n  state = { hasError: false };\n  \n  static getDerivedStateFromError() {\n    return { hasError: true };\n  }\n  \n  render() {\n    if (this.state.hasError) {\n      return (\n        <button onClick={() => window.location.reload()}>\n          Failed to load. Click to retry.\n        </button>\n      );\n    }\n    return this.props.children;\n  }\n}\n```"),

    ("What's the difference between controlled and uncontrolled components?",
     "Controlled components have React manage form state; uncontrolled use DOM refs:\n\n```jsx\nimport { useState, useRef } from 'react';\n\n// CONTROLLED: React is the source of truth\nfunction ControlledForm() {\n  const [values, setValues] = useState({\n    name: '',\n    email: ''\n  });\n  \n  const handleChange = (e) => {\n    const { name, value } = e.target;\n    setValues(prev => ({ ...prev, [name]: value }));\n  };\n  \n  const handleSubmit = (e) => {\n    e.preventDefault();\n    console.log('Submitted:', values);\n  };\n  \n  return (\n    <form onSubmit={handleSubmit}>\n      <input\n        name=\"name\"\n        value={values.name}  // Controlled by state\n        onChange={handleChange}\n      />\n      <input\n        name=\"email\"\n        value={values.email}\n        onChange={handleChange}\n      />\n      <button type=\"submit\">Submit</button>\n    </form>\n  );\n}\n\n// UNCONTROLLED: DOM is the source of truth\nfunction UncontrolledForm() {\n  const nameRef = useRef(null);\n  const emailRef = useRef(null);\n  \n  const handleSubmit = (e) => {\n    e.preventDefault();\n    console.log('Submitted:', {\n      name: nameRef.current.value,\n      email: emailRef.current.value\n    });\n  };\n  \n  return (\n    <form onSubmit={handleSubmit}>\n      <input\n        name=\"name\"\n        ref={nameRef}  // Access via ref\n        defaultValue=\"\"  // Initial value only\n      />\n      <input\n        name=\"email\"\n        ref={emailRef}\n        defaultValue=\"\"\n      />\n      <button type=\"submit\">Submit</button>\n    </form>\n  );\n}\n\n// File inputs are always uncontrolled\nfunction FileUpload() {\n  const fileRef = useRef(null);\n  \n  const handleUpload = () => {\n    const file = fileRef.current.files[0];\n    console.log('Selected file:', file);\n  };\n  \n  return (\n    <div>\n      <input type=\"file\" ref={fileRef} />\n      <button onClick={handleUpload}>Upload</button>\n    </div>\n  );\n}\n```\n\n**Use Controlled when:**\n- Need instant validation\n- Need to format input (e.g., phone numbers)\n- Conditional form logic\n- Need to disable submit based on values\n\n**Use Uncontrolled when:**\n- Simple forms with no validation\n- Integrating with non-React code\n- File inputs (required)"),

    ("How do I share logic between components?",
     "Multiple patterns for sharing stateful logic:\n\n```jsx\n// 1. CUSTOM HOOKS (preferred)\nfunction useWindowSize() {\n  const [size, setSize] = useState({\n    width: window.innerWidth,\n    height: window.innerHeight\n  });\n  \n  useEffect(() => {\n    const handleResize = () => setSize({\n      width: window.innerWidth,\n      height: window.innerHeight\n    });\n    \n    window.addEventListener('resize', handleResize);\n    return () => window.removeEventListener('resize', handleResize);\n  }, []);\n  \n  return size;\n}\n\n// Use in any component\nfunction ResponsiveLayout() {\n  const { width } = useWindowSize();\n  return width > 768 ? <Desktop /> : <Mobile />;\n}\n\n// 2. HIGHER-ORDER COMPONENTS (HOC)\nfunction withAuth(Component) {\n  return function AuthenticatedComponent(props) {\n    const { user, loading } = useAuth();\n    \n    if (loading) return <Spinner />;\n    if (!user) return <Navigate to=\"/login\" />;\n    \n    return <Component {...props} user={user} />;\n  };\n}\n\n// Wrap component\nconst ProtectedDashboard = withAuth(Dashboard);\n\n// 3. RENDER PROPS\nfunction MousePosition({ render }) {\n  const [pos, setPos] = useState({ x: 0, y: 0 });\n  \n  useEffect(() => {\n    const handleMove = (e) => setPos({ x: e.clientX, y: e.clientY });\n    window.addEventListener('mousemove', handleMove);\n    return () => window.removeEventListener('mousemove', handleMove);\n  }, []);\n  \n  return render(pos);\n}\n\n<MousePosition render={({ x, y }) => (\n  <div>Cursor: {x}, {y}</div>\n)} />\n\n// 4. COMPOUND COMPONENTS\nconst Accordion = ({ children }) => {\n  const [openIndex, setOpenIndex] = useState(null);\n  \n  return (\n    <AccordionContext.Provider value={{ openIndex, setOpenIndex }}>\n      {children}\n    </AccordionContext.Provider>\n  );\n};\n\nAccordion.Item = ({ index, title, children }) => {\n  const { openIndex, setOpenIndex } = useContext(AccordionContext);\n  const isOpen = openIndex === index;\n  \n  return (\n    <div>\n      <button onClick={() => setOpenIndex(isOpen ? null : index)}>\n        {title}\n      </button>\n      {isOpen && <div>{children}</div>}\n    </div>\n  );\n};\n\n// Usage\n<Accordion>\n  <Accordion.Item index={0} title=\"Section 1\">Content 1</Accordion.Item>\n  <Accordion.Item index={1} title=\"Section 2\">Content 2</Accordion.Item>\n</Accordion>\n```"),

    ("How do I test React components?",
     "Use React Testing Library for component testing:\n\n```jsx\nimport { render, screen, fireEvent, waitFor } from '@testing-library/react';\nimport userEvent from '@testing-library/user-event';\nimport { Counter } from './Counter';\nimport { UserProfile } from './UserProfile';\n\n// Basic render and query test\ntest('renders counter with initial value', () => {\n  render(<Counter initialValue={5} />);\n  \n  // Query by text content\n  expect(screen.getByText('Count: 5')).toBeInTheDocument();\n  \n  // Query by role (preferred)\n  expect(screen.getByRole('button', { name: /increment/i })).toBeInTheDocument();\n});\n\n// User interaction test\ntest('increments counter on button click', async () => {\n  const user = userEvent.setup();\n  render(<Counter initialValue={0} />);\n  \n  const button = screen.getByRole('button', { name: /increment/i });\n  await user.click(button);\n  \n  expect(screen.getByText('Count: 1')).toBeInTheDocument();\n});\n\n// Form testing\ntest('submits form with entered data', async () => {\n  const handleSubmit = jest.fn();\n  const user = userEvent.setup();\n  render(<LoginForm onSubmit={handleSubmit} />);\n  \n  await user.type(screen.getByLabelText(/email/i), 'test@example.com');\n  await user.type(screen.getByLabelText(/password/i), 'password123');\n  await user.click(screen.getByRole('button', { name: /submit/i }));\n  \n  expect(handleSubmit).toHaveBeenCalledWith({\n    email: 'test@example.com',\n    password: 'password123'\n  });\n});\n\n// Async data fetching test\ntest('loads and displays user data', async () => {\n  // Mock fetch\n  global.fetch = jest.fn(() =>\n    Promise.resolve({\n      json: () => Promise.resolve({ name: 'John', email: 'john@test.com' })\n    })\n  );\n  \n  render(<UserProfile userId=\"123\" />);\n  \n  // Wait for async data\n  expect(screen.getByText(/loading/i)).toBeInTheDocument();\n  \n  await waitFor(() => {\n    expect(screen.getByText('John')).toBeInTheDocument();\n  });\n  \n  expect(fetch).toHaveBeenCalledWith('/api/users/123');\n});\n\n// Testing with context\ntest('uses theme from context', () => {\n  render(\n    <ThemeProvider value=\"dark\">\n      <ThemedButton />\n    </ThemeProvider>\n  );\n  \n  expect(screen.getByRole('button')).toHaveClass('dark-theme');\n});\n```\nQueries priority: getByRole > getByLabelText > getByText > getByTestId"),

    ("What are React Server Components?",
     "Server Components render on the server, reducing client bundle size:\n\n```jsx\n// Server Component (default in Next.js 13+ app router)\n// Can be async, access databases directly, no client-side hooks\n\n// app/page.tsx - Server Component\nimport { db } from '@/lib/db';\n\nasync function ProductList() {\n  // Direct database access - runs only on server\n  const products = await db.products.findMany();\n  \n  return (\n    <div>\n      <h1>Products</h1>\n      {products.map(product => (\n        <ProductCard key={product.id} product={product} />\n      ))}\n    </div>\n  );\n}\n\n// Client Component - add 'use client' directive\n// components/AddToCart.tsx\n'use client';\n\nimport { useState } from 'react';\n\nexport function AddToCart({ productId }) {\n  const [quantity, setQuantity] = useState(1);\n  \n  const handleAdd = async () => {\n    await fetch('/api/cart', {\n      method: 'POST',\n      body: JSON.stringify({ productId, quantity })\n    });\n  };\n  \n  return (\n    <div>\n      <input\n        type=\"number\"\n        value={quantity}\n        onChange={e => setQuantity(Number(e.target.value))}\n      />\n      <button onClick={handleAdd}>Add to Cart</button>\n    </div>\n  );\n}\n\n// Mixing Server and Client Components\n// Server Component can import Client Component\nimport { AddToCart } from '@/components/AddToCart';\n\nasync function ProductPage({ id }) {\n  const product = await getProduct(id);  // Server-side fetch\n  \n  return (\n    <div>\n      <h1>{product.name}</h1>  {/* Rendered on server */}\n      <p>{product.description}</p>\n      <AddToCart productId={id} />  {/* Client interactive */}\n    </div>\n  );\n}\n```\n\n**Server Components:**\n- ✓ Zero bundle size impact\n- ✓ Direct backend access\n- ✓ Async data fetching\n- ✗ No useState, useEffect, event handlers\n\n**Client Components:**\n- ✓ Interactivity (clicks, forms)\n- ✓ Browser APIs\n- ✓ All hooks available\n- ✗ Larger bundle"),

    ("How do I optimize React performance?",
     "Key techniques for React performance optimization:\n\n```jsx\nimport { memo, useMemo, useCallback, lazy, Suspense } from 'react';\n\n// 1. MEMOIZE EXPENSIVE COMPONENTS\nconst ExpensiveList = memo(function ExpensiveList({ items, onSelect }) {\n  return items.map(item => (\n    <div key={item.id} onClick={() => onSelect(item.id)}>\n      {item.name}\n    </div>\n  ));\n});\n\n// 2. MEMOIZE COMPUTED VALUES\nfunction SearchResults({ items, query }) {\n  // Only recomputes when items or query changes\n  const filtered = useMemo(() => {\n    return items.filter(item =>\n      item.name.toLowerCase().includes(query.toLowerCase())\n    );\n  }, [items, query]);\n  \n  return <ItemList items={filtered} />;\n}\n\n// 3. STABLE CALLBACK REFERENCES\nfunction Parent() {\n  const [count, setCount] = useState(0);\n  \n  // Stable reference - doesn't cause child re-renders\n  const handleClick = useCallback((id) => {\n    console.log('Clicked:', id);\n  }, []);\n  \n  return <Child onClick={handleClick} />;\n}\n\n// 4. VIRTUALIZE LONG LISTS\nimport { FixedSizeList } from 'react-window';\n\nfunction VirtualizedList({ items }) {\n  return (\n    <FixedSizeList\n      height={400}\n      width={300}\n      itemCount={items.length}\n      itemSize={50}\n    >\n      {({ index, style }) => (\n        <div style={style}>{items[index].name}</div>\n      )}\n    </FixedSizeList>\n  );\n}\n\n// 5. CODE SPLITTING\nconst HeavyComponent = lazy(() => import('./HeavyComponent'));\n\n// 6. AVOID INLINE OBJECTS/ARRAYS\n// BAD - creates new object every render\n<Child style={{ color: 'red' }} data={[1, 2, 3]} />\n\n// GOOD - stable references\nconst styles = { color: 'red' };\nconst data = [1, 2, 3];\n<Child style={styles} data={data} />\n\n// 7. AVOID STATE UPDATES IN LOOPS\n// BAD\nitems.forEach(item => setSelected(s => [...s, item]));\n\n// GOOD - single update\nsetSelected(s => [...s, ...items]);\n\n// 8. USE PRODUCTION BUILD\n// npm run build\n// React DevTools Profiler to find bottlenecks\n```\n\n**Profile first:** Use React DevTools Profiler before optimizing. Most apps don't need heavy optimization."),

    ("What is React Suspense and how does it work?",
     "Suspense lets components wait for data before rendering:\n\n```jsx\nimport { Suspense, lazy, useState, use } from 'react';\n\n// 1. CODE SPLITTING with lazy\nconst HeavyChart = lazy(() => import('./HeavyChart'));\n\nfunction Dashboard() {\n  return (\n    <Suspense fallback={<div>Loading chart...</div>}>\n      <HeavyChart />\n    </Suspense>\n  );\n}\n\n// 2. DATA FETCHING with React 19's use() hook\nfunction UserProfile({ userPromise }) {\n  const user = use(userPromise);  // Suspends until resolved\n  \n  return (\n    <div>\n      <h1>{user.name}</h1>\n      <p>{user.email}</p>\n    </div>\n  );\n}\n\nfunction App() {\n  const userPromise = fetchUser(1);  // Returns promise\n  \n  return (\n    <Suspense fallback={<Spinner />}>\n      <UserProfile userPromise={userPromise} />\n    </Suspense>\n  );\n}\n\n// 3. NESTED SUSPENSE boundaries\nfunction Page() {\n  return (\n    <Suspense fallback={<PageSkeleton />}>\n      <Header />\n      \n      <Suspense fallback={<SidebarSkeleton />}>\n        <Sidebar />  {/* Can load independently */}\n      </Suspense>\n      \n      <Suspense fallback={<ContentSkeleton />}>\n        <MainContent />  {/* Can load independently */}\n      </Suspense>\n    </Suspense>\n  );\n}\n\n// 4. STREAMING SSR (Next.js)\nimport { Suspense } from 'react';\n\nexport default async function Page() {\n  return (\n    <div>\n      <h1>Dashboard</h1>\n      \n      {/* Streams to client as each resolves */}\n      <Suspense fallback={<p>Loading stats...</p>}>\n        <Stats />  {/* Async Server Component */}\n      </Suspense>\n      \n      <Suspense fallback={<p>Loading feed...</p>}>\n        <ActivityFeed />  {/* Async Server Component */}\n      </Suspense>\n    </div>\n  );\n}\n\n// 5. SUSPENSELIST for coordinated loading (experimental)\nimport { SuspenseList } from 'react';\n\n<SuspenseList revealOrder=\"forwards\">\n  <Suspense fallback={<Skeleton />}>\n    <Section1 />\n  </Suspense>\n  <Suspense fallback={<Skeleton />}>\n    <Section2 />  {/* Won't show before Section1 */}\n  </Suspense>\n</SuspenseList>\n```"),

    ("How do I use React with TypeScript?",
     "TypeScript adds type safety to React components:\n\n```tsx\nimport { useState, useEffect, ReactNode, FC } from 'react';\n\n// Props interface\ninterface ButtonProps {\n  label: string;\n  onClick: () => void;\n  variant?: 'primary' | 'secondary';  // Union type\n  disabled?: boolean;\n  icon?: ReactNode;  // For JSX children\n}\n\n// Functional component with typed props\nfunction Button({ label, onClick, variant = 'primary', disabled, icon }: ButtonProps) {\n  return (\n    <button\n      className={`btn btn-${variant}`}\n      onClick={onClick}\n      disabled={disabled}\n    >\n      {icon && <span className=\"icon\">{icon}</span>}\n      {label}\n    </button>\n  );\n}\n\n// Component with children\ninterface CardProps {\n  title: string;\n  children: ReactNode;\n}\n\nconst Card: FC<CardProps> = ({ title, children }) => (\n  <div className=\"card\">\n    <h2>{title}</h2>\n    {children}\n  </div>\n);\n\n// useState with types\ninterface User {\n  id: number;\n  name: string;\n  email: string;\n}\n\nfunction UserList() {\n  const [users, setUsers] = useState<User[]>([]);\n  const [loading, setLoading] = useState<boolean>(true);\n  const [selected, setSelected] = useState<User | null>(null);\n  \n  return <div>...</div>;\n}\n\n// Event handlers\nfunction Form() {\n  const handleChange = (e: React.ChangeEvent<HTMLInputElement>) => {\n    console.log(e.target.value);\n  };\n  \n  const handleSubmit = (e: React.FormEvent<HTMLFormElement>) => {\n    e.preventDefault();\n  };\n  \n  const handleClick = (e: React.MouseEvent<HTMLButtonElement>) => {\n    console.log(e.clientX);\n  };\n  \n  return <form onSubmit={handleSubmit}>...</form>;\n}\n\n// useRef with types\nfunction InputFocus() {\n  const inputRef = useRef<HTMLInputElement>(null);\n  \n  const focus = () => {\n    inputRef.current?.focus();  // Optional chaining\n  };\n  \n  return <input ref={inputRef} />;\n}\n\n// Generic components\ninterface ListProps<T> {\n  items: T[];\n  renderItem: (item: T) => ReactNode;\n}\n\nfunction List<T>({ items, renderItem }: ListProps<T>) {\n  return <ul>{items.map(renderItem)}</ul>;\n}\n\n// Usage\n<List<User>\n  items={users}\n  renderItem={(user) => <li key={user.id}>{user.name}</li>}\n/>\n```"),
]

# More React items continue here - we'll add more in batches
REACT_ITEMS_BATCH2 = [
    ("What are the key differences between React 18 and previous versions?",
     "React 18 introduced concurrent features and automatic batching:\n\n```jsx\nimport { createRoot } from 'react-dom/client';\nimport { startTransition, useTransition, useDeferredValue } from 'react';\n\n// 1. NEW ROOT API\n// Before (React 17)\nReactDOM.render(<App />, document.getElementById('root'));\n\n// After (React 18)\nconst root = createRoot(document.getElementById('root'));\nroot.render(<App />);\n\n// 2. AUTOMATIC BATCHING\n// React 18 batches all updates, even in promises/timeouts\nfunction handleClick() {\n  fetch('/api').then(() => {\n    setCount(c => c + 1);  // These are now batched\n    setFlag(f => !f);       // Single re-render!\n  });\n}\n\n// 3. TRANSITIONS for non-urgent updates\nfunction SearchResults() {\n  const [query, setQuery] = useState('');\n  const [results, setResults] = useState([]);\n  const [isPending, startTransition] = useTransition();\n  \n  const handleChange = (e) => {\n    // Urgent: update input immediately\n    setQuery(e.target.value);\n    \n    // Non-urgent: can be interrupted\n    startTransition(() => {\n      setResults(filterResults(e.target.value));\n    });\n  };\n  \n  return (\n    <div>\n      <input value={query} onChange={handleChange} />\n      {isPending && <Spinner />}\n      <ResultsList results={results} />\n    </div>\n  );\n}\n\n// 4. DEFERRED VALUES\nfunction SearchPage() {\n  const [query, setQuery] = useState('');\n  const deferredQuery = useDeferredValue(query);\n  \n  // deferredQuery lags behind query during typing\n  // Allows input to stay responsive\n  \n  return (\n    <div>\n      <input value={query} onChange={e => setQuery(e.target.value)} />\n      <Suspense fallback={<Loading />}>\n        <SearchResults query={deferredQuery} />\n      </Suspense>\n    </div>\n  );\n}\n\n// 5. SUSPENSE ON SERVER (Streaming SSR)\n// Components wrapped in Suspense can stream HTML progressively\n```\n\nKey features:\n- Concurrent rendering (interruptible)\n- Automatic batching everywhere\n- Transitions for non-urgent updates\n- Streaming SSR with Suspense"),

    ("How do I manage global state in React?",
     "Multiple approaches for global state management:\n\n```jsx\n// 1. CONTEXT + useReducer (built-in, small apps)\nconst StateContext = createContext();\nconst DispatchContext = createContext();\n\nfunction reducer(state, action) {\n  switch (action.type) {\n    case 'SET_USER': return { ...state, user: action.payload };\n    case 'SET_THEME': return { ...state, theme: action.payload };\n    default: return state;\n  }\n}\n\nfunction StateProvider({ children }) {\n  const [state, dispatch] = useReducer(reducer, { user: null, theme: 'light' });\n  \n  return (\n    <StateContext.Provider value={state}>\n      <DispatchContext.Provider value={dispatch}>\n        {children}\n      </DispatchContext.Provider>\n    </StateContext.Provider>\n  );\n}\n\n// 2. ZUSTAND (simple, popular)\nimport { create } from 'zustand';\n\nconst useStore = create((set) => ({\n  count: 0,\n  user: null,\n  increment: () => set((state) => ({ count: state.count + 1 })),\n  setUser: (user) => set({ user }),\n  reset: () => set({ count: 0, user: null }),\n}));\n\n// Usage - only re-renders when selected state changes\nfunction Counter() {\n  const count = useStore((state) => state.count);\n  const increment = useStore((state) => state.increment);\n  \n  return <button onClick={increment}>{count}</button>;\n}\n\n// 3. JOTAI (atomic state)\nimport { atom, useAtom } from 'jotai';\n\nconst countAtom = atom(0);\nconst userAtom = atom(null);\nconst doubleCountAtom = atom((get) => get(countAtom) * 2);\n\nfunction Counter() {\n  const [count, setCount] = useAtom(countAtom);\n  return <button onClick={() => setCount(c => c + 1)}>{count}</button>;\n}\n\n// 4. REDUX TOOLKIT (large apps)\nimport { configureStore, createSlice } from '@reduxjs/toolkit';\nimport { Provider, useSelector, useDispatch } from 'react-redux';\n\nconst counterSlice = createSlice({\n  name: 'counter',\n  initialState: { value: 0 },\n  reducers: {\n    increment: (state) => { state.value += 1; },\n    decrement: (state) => { state.value -= 1; },\n  },\n});\n\nconst store = configureStore({\n  reducer: { counter: counterSlice.reducer },\n});\n\nfunction Counter() {\n  const count = useSelector((state) => state.counter.value);\n  const dispatch = useDispatch();\n  \n  return (\n    <button onClick={() => dispatch(counterSlice.actions.increment())}>\n      {count}\n    </button>\n  );\n}\n```\n\nChoose based on app size:\n- Small: Context + useReducer\n- Medium: Zustand or Jotai\n- Large/Complex: Redux Toolkit"),

    ("How do I implement infinite scroll in React?",
     "Use Intersection Observer for performant infinite scroll:\n\n```jsx\nimport { useState, useEffect, useRef, useCallback } from 'react';\n\nfunction InfiniteScroll() {\n  const [items, setItems] = useState([]);\n  const [page, setPage] = useState(1);\n  const [loading, setLoading] = useState(false);\n  const [hasMore, setHasMore] = useState(true);\n  const observerRef = useRef(null);\n  \n  // Fetch data\n  const fetchItems = useCallback(async (pageNum) => {\n    setLoading(true);\n    try {\n      const res = await fetch(`/api/items?page=${pageNum}`);\n      const data = await res.json();\n      \n      setItems(prev => [...prev, ...data.items]);\n      setHasMore(data.hasMore);\n    } finally {\n      setLoading(false);\n    }\n  }, []);\n  \n  // Initial load\n  useEffect(() => {\n    fetchItems(1);\n  }, [fetchItems]);\n  \n  // Intersection Observer callback\n  const lastItemRef = useCallback((node) => {\n    if (loading) return;\n    \n    // Disconnect previous observer\n    if (observerRef.current) {\n      observerRef.current.disconnect();\n    }\n    \n    // Create new observer\n    observerRef.current = new IntersectionObserver((entries) => {\n      if (entries[0].isIntersecting && hasMore) {\n        setPage(prev => prev + 1);\n      }\n    });\n    \n    // Observe the last item\n    if (node) {\n      observerRef.current.observe(node);\n    }\n  }, [loading, hasMore]);\n  \n  // Fetch when page changes\n  useEffect(() => {\n    if (page > 1) {\n      fetchItems(page);\n    }\n  }, [page, fetchItems]);\n  \n  return (\n    <div className=\"item-list\">\n      {items.map((item, index) => (\n        <div\n          key={item.id}\n          ref={index === items.length - 1 ? lastItemRef : null}\n          className=\"item\"\n        >\n          {item.title}\n        </div>\n      ))}\n      \n      {loading && <div className=\"spinner\">Loading...</div>}\n      {!hasMore && <div className=\"end\">No more items</div>}\n    </div>\n  );\n}\n\n// Alternative: useSWRInfinite from SWR\nimport useSWRInfinite from 'swr/infinite';\n\nfunction InfiniteWithSWR() {\n  const { data, size, setSize, isLoading } = useSWRInfinite(\n    (index) => `/api/items?page=${index + 1}`,\n    fetcher\n  );\n  \n  const items = data ? data.flatMap(page => page.items) : [];\n  const hasMore = data && data[data.length - 1]?.hasMore;\n  \n  return (\n    <div>\n      {items.map(item => <Item key={item.id} {...item} />)}\n      <button\n        onClick={() => setSize(size + 1)}\n        disabled={isLoading || !hasMore}\n      >\n        Load More\n      </button>\n    </div>\n  );\n}\n```"),

    ("How do I handle authentication in React?",
     "Common patterns for authentication flow:\n\n```jsx\nimport { createContext, useContext, useState, useEffect } from 'react';\nimport { Navigate, useLocation } from 'react-router-dom';\n\n// Auth Context\nconst AuthContext = createContext(null);\n\nexport function AuthProvider({ children }) {\n  const [user, setUser] = useState(null);\n  const [loading, setLoading] = useState(true);\n  \n  // Check auth status on mount\n  useEffect(() => {\n    checkAuth();\n  }, []);\n  \n  const checkAuth = async () => {\n    try {\n      const res = await fetch('/api/auth/me', {\n        credentials: 'include'  // Include cookies\n      });\n      if (res.ok) {\n        setUser(await res.json());\n      }\n    } finally {\n      setLoading(false);\n    }\n  };\n  \n  const login = async (email, password) => {\n    const res = await fetch('/api/auth/login', {\n      method: 'POST',\n      headers: { 'Content-Type': 'application/json' },\n      credentials: 'include',\n      body: JSON.stringify({ email, password })\n    });\n    \n    if (!res.ok) {\n      throw new Error('Login failed');\n    }\n    \n    const userData = await res.json();\n    setUser(userData);\n    return userData;\n  };\n  \n  const logout = async () => {\n    await fetch('/api/auth/logout', {\n      method: 'POST',\n      credentials: 'include'\n    });\n    setUser(null);\n  };\n  \n  return (\n    <AuthContext.Provider value={{ user, loading, login, logout }}>\n      {children}\n    </AuthContext.Provider>\n  );\n}\n\nexport const useAuth = () => useContext(AuthContext);\n\n// Protected Route Component\nexport function ProtectedRoute({ children }) {\n  const { user, loading } = useAuth();\n  const location = useLocation();\n  \n  if (loading) {\n    return <div>Loading...</div>;\n  }\n  \n  if (!user) {\n    // Redirect to login, save intended destination\n    return <Navigate to=\"/login\" state={{ from: location }} replace />;\n  }\n  \n  return children;\n}\n\n// Login Page\nfunction LoginPage() {\n  const { login } = useAuth();\n  const navigate = useNavigate();\n  const location = useLocation();\n  const [error, setError] = useState('');\n  \n  const from = location.state?.from?.pathname || '/';\n  \n  const handleSubmit = async (e) => {\n    e.preventDefault();\n    const formData = new FormData(e.target);\n    \n    try {\n      await login(formData.get('email'), formData.get('password'));\n      navigate(from, { replace: true });\n    } catch (err) {\n      setError(err.message);\n    }\n  };\n  \n  return (\n    <form onSubmit={handleSubmit}>\n      {error && <p className=\"error\">{error}</p>}\n      <input name=\"email\" type=\"email\" required />\n      <input name=\"password\" type=\"password\" required />\n      <button type=\"submit\">Login</button>\n    </form>\n  );\n}\n\n// App with protected routes\nfunction App() {\n  return (\n    <AuthProvider>\n      <Routes>\n        <Route path=\"/login\" element={<LoginPage />} />\n        <Route path=\"/\" element={\n          <ProtectedRoute>\n            <Dashboard />\n          </ProtectedRoute>\n        } />\n      </Routes>\n    </AuthProvider>\n  );\n}\n```"),

    ("How do I debounce and throttle in React?",
     "Debouncing delays execution; throttling limits frequency:\n\n```jsx\nimport { useState, useEffect, useCallback, useRef } from 'react';\n\n// DEBOUNCE HOOK - delays until activity stops\nfunction useDebounce(value, delay = 500) {\n  const [debouncedValue, setDebouncedValue] = useState(value);\n  \n  useEffect(() => {\n    const timer = setTimeout(() => {\n      setDebouncedValue(value);\n    }, delay);\n    \n    return () => clearTimeout(timer);\n  }, [value, delay]);\n  \n  return debouncedValue;\n}\n\n// Usage: Search with debounce\nfunction SearchInput() {\n  const [query, setQuery] = useState('');\n  const debouncedQuery = useDebounce(query, 300);\n  const [results, setResults] = useState([]);\n  \n  useEffect(() => {\n    if (debouncedQuery) {\n      fetch(`/api/search?q=${debouncedQuery}`)\n        .then(r => r.json())\n        .then(setResults);\n    }\n  }, [debouncedQuery]);\n  \n  return (\n    <div>\n      <input\n        value={query}\n        onChange={e => setQuery(e.target.value)}\n        placeholder=\"Search...\"\n      />\n      <ul>{results.map(r => <li key={r.id}>{r.name}</li>)}</ul>\n    </div>\n  );\n}\n\n// DEBOUNCED CALLBACK\nfunction useDebouncedCallback(callback, delay) {\n  const timeoutRef = useRef(null);\n  \n  const debouncedFn = useCallback((...args) => {\n    if (timeoutRef.current) {\n      clearTimeout(timeoutRef.current);\n    }\n    timeoutRef.current = setTimeout(() => {\n      callback(...args);\n    }, delay);\n  }, [callback, delay]);\n  \n  // Cleanup on unmount\n  useEffect(() => {\n    return () => clearTimeout(timeoutRef.current);\n  }, []);\n  \n  return debouncedFn;\n}\n\n// THROTTLE HOOK - limits execution rate\nfunction useThrottle(value, interval = 500) {\n  const [throttledValue, setThrottledValue] = useState(value);\n  const lastExecuted = useRef(Date.now());\n  \n  useEffect(() => {\n    if (Date.now() >= lastExecuted.current + interval) {\n      lastExecuted.current = Date.now();\n      setThrottledValue(value);\n    } else {\n      const timer = setTimeout(() => {\n        lastExecuted.current = Date.now();\n        setThrottledValue(value);\n      }, interval);\n      \n      return () => clearTimeout(timer);\n    }\n  }, [value, interval]);\n  \n  return throttledValue;\n}\n\n// Usage: Scroll position with throttle\nfunction ScrollTracker() {\n  const [scrollY, setScrollY] = useState(0);\n  const throttledScrollY = useThrottle(scrollY, 100);\n  \n  useEffect(() => {\n    const handleScroll = () => setScrollY(window.scrollY);\n    window.addEventListener('scroll', handleScroll);\n    return () => window.removeEventListener('scroll', handleScroll);\n  }, []);\n  \n  // Only updates every 100ms max\n  useEffect(() => {\n    console.log('Scroll position:', throttledScrollY);\n  }, [throttledScrollY]);\n  \n  return <div>Scroll: {throttledScrollY}px</div>;\n}\n```"),

    ("How do I handle drag and drop in React?",
     "Using the native HTML5 API or react-dnd library:\n\n```jsx\nimport { useState } from 'react';\n\n// NATIVE HTML5 DRAG AND DROP\nfunction DraggableList() {\n  const [items, setItems] = useState(['Item 1', 'Item 2', 'Item 3']);\n  const [draggedIdx, setDraggedIdx] = useState(null);\n  \n  const handleDragStart = (e, index) => {\n    setDraggedIdx(index);\n    e.dataTransfer.effectAllowed = 'move';\n  };\n  \n  const handleDragOver = (e, index) => {\n    e.preventDefault();\n    if (draggedIdx === index) return;\n    \n    // Reorder items\n    const newItems = [...items];\n    const [removed] = newItems.splice(draggedIdx, 1);\n    newItems.splice(index, 0, removed);\n    \n    setItems(newItems);\n    setDraggedIdx(index);\n  };\n  \n  return (\n    <ul>\n      {items.map((item, index) => (\n        <li\n          key={item}\n          draggable\n          onDragStart={(e) => handleDragStart(e, index)}\n          onDragOver={(e) => handleDragOver(e, index)}\n          onDragEnd={() => setDraggedIdx(null)}\n          className={draggedIdx === index ? 'dragging' : ''}\n        >\n          {item}\n        </li>\n      ))}\n    </ul>\n  );\n}\n\n// FILE DROP ZONE\nfunction FileDropZone({ onFilesDropped }) {\n  const [isDragging, setIsDragging] = useState(false);\n  \n  const handleDrag = (e) => {\n    e.preventDefault();\n    e.stopPropagation();\n  };\n  \n  const handleDragIn = (e) => {\n    e.preventDefault();\n    setIsDragging(true);\n  };\n  \n  const handleDragOut = (e) => {\n    e.preventDefault();\n    setIsDragging(false);\n  };\n  \n  const handleDrop = (e) => {\n    e.preventDefault();\n    setIsDragging(false);\n    \n    const files = [...e.dataTransfer.files];\n    if (files.length > 0) {\n      onFilesDropped(files);\n    }\n  };\n  \n  return (\n    <div\n      className={`drop-zone ${isDragging ? 'dragging' : ''}`}\n      onDragEnter={handleDragIn}\n      onDragLeave={handleDragOut}\n      onDragOver={handleDrag}\n      onDrop={handleDrop}\n    >\n      {isDragging ? 'Drop files here' : 'Drag files to upload'}\n    </div>\n  );\n}\n\n// USING @dnd-kit (modern, accessible)\nimport {\n  DndContext,\n  closestCenter,\n  useSensor,\n  useSensors,\n  PointerSensor,\n} from '@dnd-kit/core';\nimport {\n  arrayMove,\n  SortableContext,\n  useSortable,\n  verticalListSortingStrategy,\n} from '@dnd-kit/sortable';\n\nfunction SortableItem({ id }) {\n  const { attributes, listeners, setNodeRef, transform } = useSortable({ id });\n  \n  const style = transform ? {\n    transform: `translate3d(${transform.x}px, ${transform.y}px, 0)`,\n  } : undefined;\n  \n  return (\n    <div ref={setNodeRef} style={style} {...attributes} {...listeners}>\n      {id}\n    </div>\n  );\n}\n\nfunction SortableList() {\n  const [items, setItems] = useState(['A', 'B', 'C']);\n  const sensors = useSensors(useSensor(PointerSensor));\n  \n  const handleDragEnd = (event) => {\n    const { active, over } = event;\n    if (active.id !== over.id) {\n      setItems((items) => {\n        const oldIndex = items.indexOf(active.id);\n        const newIndex = items.indexOf(over.id);\n        return arrayMove(items, oldIndex, newIndex);\n      });\n    }\n  };\n  \n  return (\n    <DndContext sensors={sensors} collisionDetection={closestCenter} onDragEnd={handleDragEnd}>\n      <SortableContext items={items} strategy={verticalListSortingStrategy}>\n        {items.map(id => <SortableItem key={id} id={id} />)}\n      </SortableContext>\n    </DndContext>\n  );\n}\n```"),

    ("How do I handle animations in React?",
     "Multiple approaches for animations:\n\n```jsx\nimport { useState, useRef, useEffect } from 'react';\n\n// 1. CSS TRANSITIONS (simplest)\nfunction CSSTransition() {\n  const [isOpen, setIsOpen] = useState(false);\n  \n  return (\n    <div>\n      <button onClick={() => setIsOpen(!isOpen)}>Toggle</button>\n      <div\n        className={`panel ${isOpen ? 'open' : 'closed'}`}\n        style={{\n          transition: 'all 0.3s ease',\n          opacity: isOpen ? 1 : 0,\n          transform: isOpen ? 'translateY(0)' : 'translateY(-20px)',\n          maxHeight: isOpen ? '500px' : '0',\n          overflow: 'hidden'\n        }}\n      >\n        Content here\n      </div>\n    </div>\n  );\n}\n\n// 2. FRAMER MOTION (recommended library)\nimport { motion, AnimatePresence } from 'framer-motion';\n\nfunction FramerExample() {\n  const [items, setItems] = useState([1, 2, 3]);\n  \n  return (\n    <div>\n      <button onClick={() => setItems([...items, items.length + 1])}>\n        Add\n      </button>\n      \n      <motion.ul layout>  {/* Layout animation */}\n        <AnimatePresence>  {/* Exit animations */}\n          {items.map(item => (\n            <motion.li\n              key={item}\n              initial={{ opacity: 0, x: -100 }}\n              animate={{ opacity: 1, x: 0 }}\n              exit={{ opacity: 0, x: 100 }}\n              transition={{ duration: 0.3 }}\n              whileHover={{ scale: 1.05 }}\n              whileTap={{ scale: 0.95 }}\n              onClick={() => setItems(items.filter(i => i !== item))}\n            >\n              Item {item}\n            </motion.li>\n          ))}\n        </AnimatePresence>\n      </motion.ul>\n    </div>\n  );\n}\n\n// Page transitions\nfunction PageTransition({ children }) {\n  return (\n    <motion.div\n      initial={{ opacity: 0, y: 20 }}\n      animate={{ opacity: 1, y: 0 }}\n      exit={{ opacity: 0, y: -20 }}\n      transition={{ duration: 0.2 }}\n    >\n      {children}\n    </motion.div>\n  );\n}\n\n// 3. REACT SPRING (physics-based)\nimport { useSpring, animated } from '@react-spring/web';\n\nfunction SpringExample() {\n  const [flip, setFlip] = useState(false);\n  \n  const props = useSpring({\n    to: { opacity: 1, transform: flip ? 'rotateX(180deg)' : 'rotateX(0deg)' },\n    from: { opacity: 0, transform: 'rotateX(0deg)' },\n    reset: true,\n  });\n  \n  return (\n    <animated.div style={props} onClick={() => setFlip(!flip)}>\n      Click to flip\n    </animated.div>\n  );\n}\n\n// 4. WEB ANIMATIONS API (native)\nfunction NativeAnimation() {\n  const boxRef = useRef(null);\n  \n  const animate = () => {\n    boxRef.current.animate(\n      [\n        { transform: 'scale(1)', opacity: 1 },\n        { transform: 'scale(1.2)', opacity: 0.8 },\n        { transform: 'scale(1)', opacity: 1 }\n      ],\n      { duration: 500, easing: 'ease-in-out' }\n    );\n  };\n  \n  return (\n    <div ref={boxRef} onClick={animate}>\n      Click to animate\n    </div>\n  );\n}\n```"),

    ("What is prop drilling and how do I avoid it?",
     "Prop drilling is passing props through many component levels:\n\n```jsx\n// PROBLEM: Prop drilling\nfunction App() {\n  const [user, setUser] = useState({ name: 'John' });\n  \n  return <Layout user={user} setUser={setUser} />;\n}\n\nfunction Layout({ user, setUser }) {\n  return <Sidebar user={user} setUser={setUser} />;\n}\n\nfunction Sidebar({ user, setUser }) {\n  return <UserProfile user={user} setUser={setUser} />;\n}\n\nfunction UserProfile({ user, setUser }) {\n  // Finally use it here, 3 levels deep!\n  return <div>{user.name}</div>;\n}\n\n// SOLUTION 1: Context API\nconst UserContext = createContext();\n\nfunction App() {\n  const [user, setUser] = useState({ name: 'John' });\n  \n  return (\n    <UserContext.Provider value={{ user, setUser }}>\n      <Layout />\n    </UserContext.Provider>\n  );\n}\n\nfunction Layout() {\n  return <Sidebar />;  // No props needed\n}\n\nfunction Sidebar() {\n  return <UserProfile />;  // No props needed\n}\n\nfunction UserProfile() {\n  const { user, setUser } = useContext(UserContext);  // Access directly\n  return <div>{user.name}</div>;\n}\n\n// SOLUTION 2: Component Composition\nfunction App() {\n  const [user, setUser] = useState({ name: 'John' });\n  \n  return (\n    <Layout>\n      <Sidebar>\n        <UserProfile user={user} setUser={setUser} />\n      </Sidebar>\n    </Layout>\n  );\n}\n\nfunction Layout({ children }) {\n  return <main className=\"layout\">{children}</main>;\n}\n\nfunction Sidebar({ children }) {\n  return <aside className=\"sidebar\">{children}</aside>;\n}\n\n// SOLUTION 3: Zustand or other state managers\nimport { create } from 'zustand';\n\nconst useUserStore = create((set) => ({\n  user: { name: 'John' },\n  setUser: (user) => set({ user }),\n}));\n\nfunction UserProfile() {\n  const user = useUserStore((state) => state.user);\n  return <div>{user.name}</div>;\n}\n\n// SOLUTION 4: Render props / children as function\nfunction UserProvider({ children }) {\n  const [user, setUser] = useState({ name: 'John' });\n  return children({ user, setUser });\n}\n\nfunction App() {\n  return (\n    <UserProvider>\n      {({ user, setUser }) => (\n        <Layout>\n          <UserProfile user={user} />\n        </Layout>\n      )}\n    </UserProvider>\n  );\n}\n```\n\nWhen to use each:\n- **Context**: Theme, auth, locale - rarely changing, widely needed\n- **Composition**: UI layout, wrapping components\n- **State library**: Complex state, frequent updates, many consumers\n- **Props**: 1-2 levels deep, or data specific to that branch"),

    ("How do I implement dark mode in React?",
     "Implementing theme switching with persistence:\n\n```jsx\nimport { createContext, useContext, useState, useEffect } from 'react';\n\n// Theme Context\nconst ThemeContext = createContext();\n\nexport function ThemeProvider({ children }) {\n  // Initialize from localStorage or system preference\n  const [theme, setTheme] = useState(() => {\n    const saved = localStorage.getItem('theme');\n    if (saved) return saved;\n    \n    // Check system preference\n    return window.matchMedia('(prefers-color-scheme: dark)').matches\n      ? 'dark'\n      : 'light';\n  });\n  \n  // Apply theme to document\n  useEffect(() => {\n    const root = document.documentElement;\n    root.setAttribute('data-theme', theme);\n    localStorage.setItem('theme', theme);\n  }, [theme]);\n  \n  // Listen for system preference changes\n  useEffect(() => {\n    const mediaQuery = window.matchMedia('(prefers-color-scheme: dark)');\n    const handleChange = (e) => {\n      if (!localStorage.getItem('theme')) {\n        setTheme(e.matches ? 'dark' : 'light');\n      }\n    };\n    \n    mediaQuery.addEventListener('change', handleChange);\n    return () => mediaQuery.removeEventListener('change', handleChange);\n  }, []);\n  \n  const toggleTheme = () => {\n    setTheme(prev => prev === 'light' ? 'dark' : 'light');\n  };\n  \n  return (\n    <ThemeContext.Provider value={{ theme, setTheme, toggleTheme }}>\n      {children}\n    </ThemeContext.Provider>\n  );\n}\n\nexport const useTheme = () => useContext(ThemeContext);\n\n// Theme Toggle Button\nfunction ThemeToggle() {\n  const { theme, toggleTheme } = useTheme();\n  \n  return (\n    <button onClick={toggleTheme} aria-label=\"Toggle theme\">\n      {theme === 'light' ? '🌙' : '☀️'}\n    </button>\n  );\n}\n\n/* CSS with CSS Variables */\n/* \n:root {\n  --bg-color: #ffffff;\n  --text-color: #333333;\n  --primary-color: #007bff;\n}\n\n[data-theme=\"dark\"] {\n  --bg-color: #1a1a1a;\n  --text-color: #e0e0e0;\n  --primary-color: #4dabf7;\n}\n\nbody {\n  background-color: var(--bg-color);\n  color: var(--text-color);\n  transition: background-color 0.3s, color 0.3s;\n}\n*/\n\n// With Tailwind CSS\nfunction TailwindDarkMode() {\n  const { theme, toggleTheme } = useTheme();\n  \n  // Add 'dark' class to html element\n  useEffect(() => {\n    document.documentElement.classList.toggle('dark', theme === 'dark');\n  }, [theme]);\n  \n  return (\n    <div className=\"bg-white dark:bg-gray-900 text-gray-900 dark:text-white\">\n      <button onClick={toggleTheme}>\n        Toggle Dark Mode\n      </button>\n    </div>\n  );\n}\n\n// With styled-components\nimport styled, { ThemeProvider as StyledThemeProvider } from 'styled-components';\n\nconst themes = {\n  light: {\n    bg: '#ffffff',\n    text: '#333333',\n  },\n  dark: {\n    bg: '#1a1a1a',\n    text: '#e0e0e0',\n  },\n};\n\nconst Container = styled.div`\n  background: ${props => props.theme.bg};\n  color: ${props => props.theme.text};\n`;\n\nfunction App() {\n  const { theme } = useTheme();\n  \n  return (\n    <StyledThemeProvider theme={themes[theme]}>\n      <Container>Content</Container>\n    </StyledThemeProvider>\n  );\n}\n```"),
]


if __name__ == "__main__":
    # Generate React fundamentals
    items = []
    for i, (source, target) in enumerate(REACT_ITEMS + REACT_ITEMS_BATCH2, 1):
        items.append(create_item("react_fundamentals", i, source, target))

    lesson = create_lesson(
        "react_fundamentals",
        "React Fundamentals",
        "React components, hooks, state management, patterns",
        items,
        ["react", "frontend", "javascript"]
    )

    save_lesson("010_react_fundamentals.json", lesson)
    print(f"Total items: {len(items)}")
